设计模式
原则：
1. OCP 开放闭合原则
    对于扩展是开放的（Open for extension）
    对于修改是关闭的（Closed for modification）

2. LSP 里氏代换原则
    任何基类可以出现的地方，子类一定可以出现
    只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为

3. DIP 依赖倒转原则
    A.高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。
    B.抽象不应该依赖于具体，具体应该依赖于抽象。

4. ISP 接口隔离原则
    使用多个专门的接口比使用单一的总接口要好。
    一个类对另外一个类的依赖性应当是建立在最小的接口上的。

5. CARP 合成/聚合复用原则
    要尽量使用合成/聚合，尽量不要使用继承

设计模式分为三种类型，共23种。
创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。


【创建型模式】
1. 抽象工厂模式 Abstract Method 【对工厂的抽象实现】
    多个产品等级结构，对相似的工厂模式抽象，子类实现不同的工厂
2. 建造者模式 Builder Method
    将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示
3. 工厂模式 Factory Method
    一个产品等级结构
4. 原型模式 ProtoType Method
    用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象 【prefab？】
5. 单例模式 Singleton Method
    使得类的一个对象成为系统中的唯一实例

【结构型模式】
1. 适配器模式 Adapter Method
    将一个类的接口转换成客户希望的另外一个接口，类似包装原有的类
2. 桥接模式 Bridge Method
    将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化
3. 组合模式 Composite Method
    将对象组合成树形结构以表示“部分-整体”的层次结构
4. 装饰模式 Decorator Method
    不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。通过创建一个包装对象，也就是装饰来包裹真实的对象
5. 外观模式 Facade Method
    为子系统中的一组接口提供一个一致的界面，定义一个高层接口
6. 享元模式 Flyweight Method
    运用共享技术有效的支持大量细粒度的对象
7. 代理模式 Proxy Method
    为其他对象提供一种代理以控制对这个对象的访问

【行为型模式】
1. 指责链模式 Chain of Responsibility
    将处理对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它
2. 命令模式 Command Method
    对命令进行封装，将发出命令的责任和执行命令的责任分割开
3. 解析器模式 Interpreter Method
    给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子
4. 迭代器模式 Iterator Method
    提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示
5. 中介模式 Mediator Method
    用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
6. 备忘录模式 Memento Method
    在不破坏封闭的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
7. 观察者模式 Observer Method
    一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知
8. 状态模式 State Method
    当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类
9. 策略模式 Strategy Method
    定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换
10. 模板模式 Template Method
    定义一个操作中的算法的骨架，而将一些步骤延迟到子类中
11. 访问者模式 Visitor Method
    表示一个作用于某对象结构中的各元素的操作



